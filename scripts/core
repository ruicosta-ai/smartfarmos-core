#!/usr/bin/env bash
# SmartFarm OS - Core Orchestrator
# Uso: core [start|stop|restart|status|logs|prune|help] [opções]
set -Eeuo pipefail

# === CONFIGURÁVEIS ===
# Caminho do compose (ajusta se necessário)
COMPOSE_FILE="${COMPOSE_FILE:-docker/compose.yml}"
PROJECT_DIR="${PROJECT_DIR:-$(cd "$(dirname "${BASH_SOURCE[0]}")/.." && pwd)}"
PROJECT_NAME="${PROJECT_NAME:-smartfarm-core}"

# Hooks (opcionais) — podes sobrepor via .env
HOOK_MIGRATE="${HOOK_MIGRATE:-}"
HOOK_SEED="${HOOK_SEED:-}"

# Perfis do compose (opcional, ex.: dev/prod)
COMPOSE_PROFILES="${COMPOSE_PROFILES:-}"

# Nomes de contentores que podem causar conflito devido a container_name fixo em compose
CONFLICT_CONTAINERS="${CONFLICT_CONTAINERS:-sfos-mqtt sfos-db sfos-core}"

# Porta MQTT (para deteção de conflitos)
MQTT_PORT="${MQTT_PORT:-}"   # deprecated; usar MQTT_PUBLISHED_PORT para porta publicada
DB_WAIT_SECS="${DB_WAIT_SECS:-120}"   # tempo máximo para aguardar saúde da BD

# === UTILITÁRIOS ===
log()  { printf "\033[1;32m[core]\033[0m %s\n" "$*"; }
warn() { printf "\033[1;33m[core]\033[0m %s\n" "$*"; }
err()  { printf "\033[1;31m[core]\033[0m %s\n" "$*" >&2; }

die()  { err "$*"; exit 1; }

cd "$PROJECT_DIR"

# Carregar .env se existir (não exporta variáveis já definidas)
if [[ -f .env ]]; then
  set -a
  # shellcheck disable=SC2046
  source .env
  set +a
fi

ensure_cmd() {
  command -v "$1" >/dev/null 2>&1 || die "Comando obrigatório não encontrado: $1"
}

ensure_docker_running() {
  # If Docker is already running, we're good
  if docker info >/dev/null 2>&1; then
    return 0
  fi
  # Try to start Docker service on Linux servers (systemd)
  if command -v systemctl >/dev/null 2>&1; then
    warn "Docker não está a correr. A tentar iniciar o serviço via systemd…"
    if sudo systemctl start docker >/dev/null 2>&1; then
      # give the daemon a moment to come up
      for i in {1..15}; do
        if docker info >/dev/null 2>&1; then
          log "Docker iniciado (systemd)."
          return 0
        fi
        sleep 1
      done
    fi
    die "Não foi possível iniciar o serviço Docker via systemd. Verifica a instalação e permissões."
  fi
  # On macOS, we don't auto-start Docker Desktop to avoid popups; instruct the user.
  if [[ "$OSTYPE" == darwin* ]]; then
    die "Docker não está a correr. Abre o Docker Desktop e volta a executar: ./scripts/core start"
  fi
  # Fallback: unknown environment
  die "Docker não está a correr ou sem permissões. Inicia o Docker e tenta novamente."
}

compose() {
  if [[ -n "$COMPOSE_PROFILES" ]]; then
    docker compose -p "$PROJECT_NAME" -f "$COMPOSE_FILE" --profile "$COMPOSE_PROFILES" "$@"
  else
    docker compose -p "$PROJECT_NAME" -f "$COMPOSE_FILE" "$@"
  fi
}

# Obtém o ID do contentor de um serviço compose
compose_cid() {
  docker compose -p "$PROJECT_NAME" -f "$COMPOSE_FILE" ps -q "$1" 2>/dev/null | head -n1
}

# Aguarda até um serviço estar com health=healthy (se tiver healthcheck); caso não tenha, faz fallback para espera por TCP
wait_for_healthy_if_possible() {
  local svc="$1"
  local timeout="${2:-$DB_WAIT_SECS}"
  local cid
  cid="$(compose_cid "$svc")"
  if [[ -z "$cid" ]]; then
    warn "Sem ID para serviço ${svc}; a continuar sem esperar por health."
    return 0
  fi
  # Verifica se tem healthcheck
  if docker inspect -f '{{json .Config.Healthcheck}}' "$cid" 2>/dev/null | grep -qv 'null'; then
    log "A aguardar health=healthy para serviço ${svc} (até ${timeout}s)…"
    local status=""
    for ((i=1; i<=timeout; i++)); do
      status="$(docker inspect -f '{{.State.Health.Status}}' "$cid" 2>/dev/null || true)"
      if [[ "$status" == "healthy" ]]; then
        log "Serviço ${svc} está healthy."
        return 0
      fi
      sleep 1
    done
    warn "Timeout à espera de health=healthy no serviço ${svc} (último estado: ${status:-desconhecido})."
    return 1
  else
    # Fallback: se for DB, espera pela porta TCP
    if [[ "$svc" == "${DB_SERVICE:-db}" ]]; then
      wait_for_postgres
    fi
    return 0
  fi
}

# Verifica se uma porta TCP está em uso (cross-platform)
port_in_use() {
  local port="$1"
  if command -v lsof >/dev/null 2>&1; then
    lsof -iTCP:"$port" -sTCP:LISTEN -n -P >/dev/null 2>&1
    return $?
  elif command -v ss >/dev/null 2>&1; then
    ss -ltn "( sport = :$port )" | grep -q ":$port"
    return $?
  elif command -v netstat >/dev/null 2>&1; then
    netstat -an | grep -qE "LISTEN[[:space:]].*[:.]$port[[:space:]]"
    return $?
  else
    # fallback probe
    (echo >/dev/tcp/127.0.0.1/"$port") >/dev/null 2>&1
    return $?
  fi
}

ensure_mqtt_port_free() {
  if ! compose_has_service "mqtt"; then
    return 0
  fi
  local host_port=""
  if [[ -n "${MQTT_PUBLISHED_PORT:-}" ]]; then
    host_port="${MQTT_PUBLISHED_PORT%%:*}"
  elif [[ -n "${MQTT_PORT:-}" ]]; then
    host_port="${MQTT_PORT}"
  else
    host_port=""
  fi
  if [[ -z "$host_port" ]]; then
    return 0
  fi
  if port_in_use "$host_port"; then
    warn "Porta ${host_port} ocupada — a não iniciar o serviço mqtt para evitar conflito."
    warn "Dica: identifica o processo com:"
    warn "  lsof -iTCP:${host_port} -sTCP:LISTEN -n -P"
    warn "Se for outro container, vê com: docker ps --filter \"publish=${host_port}\""
    return 1
  fi
  return 0
}

compose_has_service() {
  docker compose -p "$PROJECT_NAME" -f "$COMPOSE_FILE" config --services 2>/dev/null | grep -qx "$1"
}

compose_up_if_exists() {
  local svc="$1"
  if compose_has_service "$svc"; then
    if ! compose up -d "$svc"; then
      warn "Falha ao iniciar serviço ${svc} (a continuar)"
      return 1
    else
      log "Serviço ${svc} iniciado (ou já em execução)."
    fi
  else
    warn "Serviço não existe no compose: ${svc} (a ignorar)"
    return 1
  fi
  return 0
}

cleanup_name_conflicts() {
  # Remove any pre-existing containers that would conflict with fixed container_name in compose
  for cname in ${CONFLICT_CONTAINERS}; do
    if docker ps -a --format '{{.Names}}' | grep -qx "$cname"; then
      warn "A remover contentor em conflito: $cname"
      docker rm -f "$cname" >/dev/null 2>&1 || true
    fi
  done
}

wait_for_postgres() {
  local svc="${DB_SERVICE:-db}"
  local host="${DB_HOST:-$svc}"
  local port="${DB_PORT:-5432}"

  log "A aguardar base de dados em ${host}:${port} (até ${DB_WAIT_SECS}s)…"
  for ((i=1; i<=DB_WAIT_SECS; i++)); do
    if (echo >"/dev/tcp/${host}/${port}") >/dev/null 2>&1; then
      log "Base de dados disponível."
      return 0
    fi
    sleep 1
  done
  warn "Timeout à espera da base de dados — as migrations podem falhar se a BD não estiver pronta."
}

cmd_start() {
  ensure_cmd docker
  ensure_cmd awk
  [[ -f "$COMPOSE_FILE" ]] || die "Ficheiro $COMPOSE_FILE não encontrado (PROJECT_DIR=$PROJECT_DIR)."

  log "Verificação do Docker daemon…"
  ensure_docker_running

  log "Pull de imagens (se aplicável)…"
  compose pull || true

  log "Build de serviços (se aplicável)…"
  compose build || true

  cleanup_name_conflicts
  log "Sobe dependências base em background…"
  compose_up_if_exists "${DB_SERVICE:-db}"
  compose_up_if_exists "redis" || true
  if ensure_mqtt_port_free; then
    log "A iniciar serviço mqtt…"
    compose_up_if_exists "mqtt" || true
  else
    # Mostrar a porta publicada definida (se existir)
    local _mqtt_host_port="${MQTT_PUBLISHED_PORT%%:*}"
    warn "A ignorar arranque do mqtt devido a conflito de porta no host ${_mqtt_host_port:-<desconhecida>}."
  fi

  # Esperar pela saúde dos serviços base (se possível)
  wait_for_healthy_if_possible "${DB_SERVICE:-db}" "$DB_WAIT_SECS" || true
  wait_for_healthy_if_possible "mqtt" "$DB_WAIT_SECS" || true

  if [[ -n "$HOOK_MIGRATE" ]]; then
    log "A aplicar migrations…"
    eval "$HOOK_MIGRATE" || die "Falha nas migrations."
  fi

  if [[ -n "$HOOK_SEED" ]]; then
    log "A aplicar seed…"
    eval "$HOOK_SEED" || warn "Seed falhou (a continuar)."
  fi

  log "A subir todos os serviços…"
  compose up -d

  sleep 1
  log "Estado atual (após up -d):"
  compose ps
}

cmd_stop() {
  local purge="${1:-}"
  if [[ "$purge" == "--purge" || "$purge" == "-v" ]]; then
    warn "A desligar TUDO e remover volumes (down -v)…"
    compose down -v
  else
    log "A desligar serviços (down)…"
    compose down
  fi
}

cmd_restart() {
  cmd_stop
  cmd_start
}

cmd_status() {
  compose ps
}

cmd_logs() {
  local svc="${1:-}"
  if [[ -n "$svc" ]]; then
    compose logs -f --tail=200 "$svc"
  else
    compose logs -f --tail=100
  fi
}

cmd_prune() {
  warn "Isto irá limpar imagens/volumes órfãos. Escreve 'YES' para confirmar:"
  read -r ans
  if [[ "$ans" == "YES" ]]; then
    docker system prune -f
    docker volume prune -f
  else
    warn "Cancelado."
  fi
}

cmd_help() {
  cat <<EOF
SmartFarm OS - Core Orchestrator

Uso:
  core start                # sobe tudo (pull/build + migrations + up -d)
  core stop [--purge|-v]    # desce (down). Com --purge remove volumes
  core restart
  core status               # estado dos serviços
  core logs [serviço]       # logs de todos ou de um serviço
  core prune                # limpa imagens/volumes órfãos (perigoso)
  core help

Variáveis úteis (.env ou ambiente):
  PROJECT_NAME        (default: smartfarm-core)
  COMPOSE_FILE        (default: docker/compose.yml)
  COMPOSE_PROFILES    (ex.: dev ou prod)
  HOOK_MIGRATE        (comando para migrations)
  HOOK_SEED           (comando para seed)
  DB_SERVICE/DB_HOST/DB_PORT (para wait de Postgres)
  DB_WAIT_SECS            (timeout para espera da BD/healthchecks; default: 120)
  MQTT_PUBLISHED_PORT     (ex.: 1884:1883 em dev, 1883:1883 em prod)
EOF
}

main() {
  local cmd="${1:-help}"; shift || true
  case "$cmd" in
    start)   cmd_start "$@";;
    stop)    cmd_stop "$@";;
    restart) cmd_restart;;
    status)  cmd_status;;
    logs)    cmd_logs "$@";;
    prune)   cmd_prune;;
    help|-h|--help) cmd_help;;
    *) err "Comando desconhecido: $cmd"; cmd_help; exit 1;;
  esac
}

main "$@"